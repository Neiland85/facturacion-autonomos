"use strict";
// Generated by Copilot
const prisma = require('../prisma/client');
const Joi = require('joi');
// Esquema de validaciÃ³n para factura
const facturaSchema = Joi.object({
    numero: Joi.string().required(),
    fecha: Joi.date().required(),
    total: Joi.number().required(),
    usuarioId: Joi.number().integer().required(),
    clienteId: Joi.number().integer().required(),
    pdfUrl: Joi.string().uri().allow(null, '')
});
exports.getAll = async (req, res) => {
    try {
        const facturas = await prisma.factura.findMany();
        res.json(facturas);
    }
    catch (error) {
        console.error('Error al obtener facturas:', error);
        res.status(500).json({ error: 'Error al obtener facturas' });
    }
};
exports.getById = async (req, res) => {
    try {
        const factura = await prisma.factura.findUnique({
            where: { id: Number(req.params.id) }
        });
        if (!factura)
            return res.status(404).json({ error: 'Factura no encontrada' });
        res.json(factura);
    }
    catch (error) {
        console.error('Error al obtener factura:', error); // Registrar el error
        res.status(500).json({ error: 'Error al obtener factura' });
    }
};
exports.create = async (req, res) => {
    const { error } = facturaSchema.validate(req.body);
    if (error)
        return res.status(400).json({ error: error.details[0].message });
    try {
        const factura = await prisma.factura.create({ data: req.body });
        res.status(201).json(factura);
    }
    catch (err) {
        res.status(500).json({ error: 'Error al crear factura' });
    }
};
exports.update = async (req, res) => {
    const { error } = facturaSchema.validate(req.body);
    if (error)
        return res.status(400).json({ error: error.details[0].message });
    try {
        const factura = await prisma.factura.update({
            where: { id: Number(req.params.id) },
            data: req.body
        });
        res.json(factura);
    }
    catch (err) {
        if (err.code === 'P2025') {
            return res.status(404).json({ error: 'Factura no encontrada' });
        }
        res.status(500).json({ error: 'Error al actualizar factura' });
    }
};
exports.delete = async (req, res) => {
    try {
        await prisma.factura.delete({ where: { id: Number(req.params.id) } });
        res.json({ message: 'Factura eliminada' });
    }
    catch (error) {
        console.error('Error al eliminar factura:', error); // Usar la variable
        res.status(500).json({ error: 'Error al eliminar factura' });
    }
};
const { getAll } = require('../controllers/facturaController');
jest.mock('../prisma/client');
test('Debe devolver una lista de facturas', async () => {
    prisma.factura.findMany.mockResolvedValue([{ id: 1, numero: 'F001' }]);
    const req = {};
    const res = {
        json: jest.fn()
    };
    await getAll(req, res);
    expect(res.json).toHaveBeenCalledWith([{ id: 1, numero: 'F001' }]);
});
const { getById } = require('../controllers/facturaController');
const prisma = require('../prisma/client');
jest.mock('../prisma/client', () => ({
    factura: {
        findUnique: jest.fn()
    }
}));
test('Debe devolver una factura por ID', async () => {
    prisma.factura.findUnique.mockResolvedValue({ id: 1, numero: 'F001' });
    const req = { params: { id: '1' } };
    const res = {
        json: jest.fn()
    };
    await getById(req, res);
    expect(res.json).toHaveBeenCalledWith({ id: 1, numero: 'F001' });
});
